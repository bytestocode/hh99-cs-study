# 13장 그렇다면 뺄셈은 어떨까요?

## 0. 자리 빌림수
- 덧셈: 자리 올림수(carry)가 발생
- 뺄셈: 자리 빌림수(borrow)가 발생

<img src="https://www.smartick.com/blog/wp-content/uploads/marisa.2.-1200x900.png" height="360px" title=""/>

## 1. 빌림없이 뺄셈하기

### 9의 보수를 사용
- 빼어지는수: 253
- 빼는 수: 176
- 9의 보수: 999 - 빼는 수(176) = 823
- 빼어지는 수(253) + 9의 보수(823) = 1076
- 1076 + 1 - 1000 = 77 
> 253 + (999 - 176) + 1 - 1000

### 빼는 수가 빼어지는 수보다 큰 경우
- 빼어지는수: 176
- 빼는 수: 253
- 빼는 수에 대한 9의 보수: 999 - 빼는 수(253) = 746
- 빼어지는 수(176) + 9의 보수(746) = 922
- 922 + 1 - 1000 = ?? (빌림이 발생)
- 922 - 999 = -(999 - 922) = -77

### 이진수로 바꾸어 봅시다
- 빼어지는 수: 1111 1101 (십진수로 253)
- 빼는 수: 1011 0000 (십진수로 176)
- 빼는 수에 대한 1의 보수: 1111 1111 - 빼는 수(1011 0000) = 0100 1111
- 실은 1의 보수에 뺄셈이 필요없음, 0은 1이 되고 1은 0이됨
- 1의 보수를 이진수의 반대 값, 역수라고 함 (인버터와 유사)
- 빼어지는 수(1111 1101) + 1의 보수(0100 1111) = 1 0100 1100
- 1 0100 1100 + 1 - 1 0000 0000 = 0100 1101 (십진수로 77)

### 빼는 수가 빼어지는 수보다 큰 경우: 이진수 버전
- 빼어지는 수: 1011 0000 (십진수로 176)
- 빼는 수: 1111 1101 (십진수로 253)
- 빼는 수에 대한 1의 보수: 1111 1111 - 빼는 수(1111 1101) = 0000 0010
- 빼어지는 수(1011 0000) + 1의 보수(0000 0010) = 1011 0010
- 1011 0010 - 1111 1111 = ?? (빌림 발생)
- 1111 1111 - 1011 0010 = 0100 1101 (77이지만 실제로는 -77, 비트를 반전시키는 것과 같은 결과)



## 2. 덧셈기(8비트 가산기)

### 더하기/빼기 전환 스위치 (입력 관련)
- 더하기: 추가 조작 없음 (SUB 신호: 0)
- 빼기: 빼는 수를 1의 보수로 변환하여 계산 (SUB 신호: 1)

#### 스위치로 조작하는 1번째
- 인버터 0, 1 조작 (8개의 XOR 게이트에 모두 입력)
- 0인 경우에 XOR 게이트: 입력 그대로 출력 (덧셈)
- 1인 경우에 XOR 게이트: 입력을 반전시켜서 출력 (덧셈)
- 따라서 8개의 XOR게이트를 1의 보수라고 표현가능

#### 스위치로 조작하는 2번째
- 뺄셈인 경우 덧셈기의 CI(자리올림 입력)에 1을 입력

#### 스위치로 조작하는 3번째
- 오버플로/언더플로
- CO(자리올림 출력)이 1인 경우
- 덧셈(SUB 0)인 경우 오버플로??
- CO(자리올림 출력)이 1인 경우??

### 9번째 전구 (출력 관련)
- 오버플로: 덧셈의 결과가 255보다 큰 경우
- 언더플로: 뺄셈의 결과가 음수인 경우



## 3. 음수를 표현하는 방법
- 이진수를 사용할 때 음수 기호를 포함한 모든 것을 0과 1로만 표현하는 것이 목표

### 부호비트를 맨 앞에 추가
- 1인 경우 음수
- 0인 경우 양수

### 새로운 방법(10의 보수)
- 양수와 음수를 같은 방식
- 숫자를 표현하기 위한 비트가 얼마나 필요한지 미리 결정해야 하는 단점
- 예를 들면 0 ~ 499는 양수 0 ~ 499를 표현 500 ~ 999는 음수 -500 ~ -1을 표현
- 10의 보수 = 9의 보수 + 1
- 10의 보수를 사용하면 일반적인 의미의 뺄셈이 필요없음

### 이진수에서는? 2의 보수를 사용
- 2의 보수 = 1의 보수 + 1 (모든 비트를 반전시킨 후 1을 더하는 것)
- 부호 있는 숫자를 나타낼 때 가장 왼쪽에 있는 비트는 부호 비트 (1이면 음수, 0이면 양수)
- 1000 0001 = -127
- 0111 1111 = 127
- cf) 부호를 나타내기 위해 부호를 표기하는 방법: 1 0111 1111 = -127 / 0 0111 1111 = 127
- 음수 기호를 따로 사용하지 않으면서도 양수와 음수를 모두 표현
- 덧셈의 규칙만을 이용하여 아주 간편하게 양수와 음수를 더함
- 숫자를 표현하기 위한 비트의 범위가 정해져 있어서 언더플로/오버플로 처리가 필요함



## 결론
- 부호가 있는(singed) 8비트 숫자: -128 ~ 127
- 부호가 없는(unsinged) 8비트 숫자: 0 ~ 255

### 1011 0110이라는 8비트 숫자를 10진수로 표현하면?
- 부호가 있는 숫자인지? 부호가 없는 숫자인지?
- -74? 182?
- 비트 사용의 어려움: 0과 1만을 나타내며 자체로 어떤 의미도 가지지 않음

### 한줄 요약

 '**부호**'가 있을 수도 있고 없을 수도 있는 '**이진수체계**' ???
