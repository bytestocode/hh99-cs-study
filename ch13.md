# 13장 그렇다면 뺄셈은 어떨까요?

## 자리 빌림수
- 덧셈: 자리 올림수(carry)가 발생
- 뺄셈: 자리 빌림수(borrow)가 발생

<img src="https://www.smartick.com/blog/wp-content/uploads/marisa.2.-1200x900.png" height="360px" title=""/>

## 빌림없이 뺄셈하기

### 9의 보수를 사용
- 빼어지는수: 253
- 빼는 수: 176
- 9의 보수: 999 - 빼는 수(176) = 823
- 빼어지는 수(253) + 9의 보수(823) = 1076
- 1076 + 1 - 1000 = 77 
> 253 + (999 - 176) + 1 - 1000

### 빼는 수가 빼어지는 수보다 큰 경우
- 빼어지는수: 176
- 빼는 수: 253
- 빼는 수에 대한 9의 보수: 999 - 빼는 수(253) = 746
- 빼어지는 수(176) + 9의 보수(746) = 922
- 922 + 1 - 1000 = ?? (빌림이 발생)
- 922 - 999 = -(999 - 922) = -77

### 이진수로 바꾸어 봅시다
- 빼어지는 수: 1111 1101 (십진수로 253)
- 빼는 수: 1011 0000 (십진수로 176)
- 빼는 수에 대한 1의 보수: 1111 1111 - 빼는 수(1011 0000) = 0100 1111
- 실은 1의 보수에 뺄셈이 필요없음, 0은 1이 되고 1은 0이됨
- 1의 보수를 이진수의 반대 값, 역수라고 함 (인버터와 유사)
- 빼어지는 수(1111 1101) + 1의 보수(0100 1111) = 1 0100 1100
- 1 0100 1100 + 1 - 1 0000 0000 = 0100 1101 (십진수로 77)

### 빼는 수가 빼어지는 수보다 큰 경우: 이진수 버전
- 빼어지는 수: 1011 0000 (십진수로 176)
- 빼는 수: 1111 1101 (십진수로 253)
- 빼는 수에 대한 1의 보수: 1111 1111 - 빼는 수(1111 1101) = 0000 0010
- 빼어지는 수(1011 0000) + 1의 보수(0000 0010) = 1011 0010
- 1011 0010 - 1111 1111 = ?? (빌림 발생)
- 1111 1111 - 1011 0010 = 0100 1101 (77이지만 실제로는 -77, 비트를 반전시키는 것과 같은 결과)


## 덧셈기(8비트 가산기)

### 더하기/빼기 전환 스위치 (입력 관련)
- 더하기: 추가 조작 없음 (SUB 신호: 0)
- 빼기: 빼는 수를 1의 보수로 변환하여 계산 (SUB 신호: 1)

#### 스위치로 조작하는 1번째
- 인버터 0, 1 조작 (8개의 XOR 게이트에 모두 입력)
- 0인 경우에 XOR 게이트: 입력 그대로 출력 (덧셈)
- 1인 경우에 XOR 게이트: 입력을 반전시켜서 출력 (덧셈)
- 따라서 8개의 XOR게이트를 1의 보수라고 표현가능

#### 스위치로 조작하는 2번째
- 뺄셈인 경우 덧셈기의 CI(자리올림 입력)에 1을 입력

#### 스위치로 조작하는 3번째
- 오버플로/언더플로
- CO(자리올림 출력)이 1인 경우
- 덧셈(SUB 0)인 경우 오버플로
- CO(자리올림 출력)이 1인 경우

### 9번째 전구 (출력 관련)
- 오버플로: 덧셈의 결과가 255보다 큰 경우
- 언더플로: 뺄셈의 결과가 음수인 경우





## 음수를 표현하는 방법


## 컴퓨터에서 음수를 저장하는 방식


## 한줄 요약

 '**부호**'가 있을 수도 있고 없을 수도 있는 '**이진수체계**'
